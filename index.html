<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Instagram ìŠ¤íƒ€ì¼ UI - p5.js</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #aaa;
      overflow-y: auto;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #phone-frame {
      position: fixed;
      top: 48%;
      left: 50%;
      width: 700px;
      height: auto;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 999;
    }
    #feed-container {
      position: fixed;
      top: 47%;
      left: 50%;
      width: 390px;
      height: 760px;
      transform: translate(-50%, -50%);
      overflow-x: hidden;
      border-radius: 55px;
      overflow-y: scroll;
      pointer-events: auto;
      z-index: 998;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    #insta-bottom {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: calc(38% + 394px);
      width: 390px;
      pointer-events: auto;
      z-index: 999;
      border-bottom-left-radius: 50px;
      border-bottom-right-radius: 50px;
      overflow: hidden;
    }

    #feed-container::-webkit-scrollbar {
      display: none;
    }
  </style>
</head>
<body>
<div id="feed-container"></div>

<img id="insta-bottom" src="insta_bottom3.png" alt="Instagram lower overlay">

<script>
// ì „ì—­ ë³€ìˆ˜ì™€ ì„¤ì • ì´ˆê¸°í™”: ì´ ë¶€ë¶„ì€ ì£¼ìš” ì• ë‹ˆë©”ì´ì…˜ ë° ìì‚° ë¡œë”©ì„ ìœ„í•œ ë³€ìˆ˜ë“¤ì„ ì •ì˜í•©ë‹ˆë‹¤.
let instaUpperImg;
let reelsImgs = [];
let reelIdx = 0;
let isReelTransitioning = false;
let prevReelIdx = 0;
let reelTransitionStart = 0;
let reelTransitionDuration = 300;
let reelTransitionDir = 0;
let reelScrollAccum = 0;
let reelScrollThreshold = 700;
let feedImgs = [];
let reel4StartTime = null;
let reel5StartTime = null;
let reel8StartTime = null;
// let idx = 0;
let bgmAudio;
let bgmSuperAudio;
let bgmKeyboardAudio;  // ì—¬ê¸° ì¶”ê°€
let bgmHappyAudio;  // ìƒˆë¡œ ì¶”ê°€

// --- Ending credits globals ---
let credits = [
      "Producer\nArt&Tech Team5",
      "Director\nProf. Jung ki-chul",
      "Writer\nChoi, Jang, Son",
      "aniA\nChoi Yoon-ha, Jang Yoon-ah",
      "aniB\nChoi Yoon-ha, Jang Yoon-ah",
      "aniC\nChoi Yoon-ha",
      "backgroundA\nJang Yoon-ah, Son homin",
      "backgroundB\nJang Yoon-ah, Son homin",
      "Music\n choi, jang, son",
      "Edit\nAll",
      "Maker\nTeam05",
      "ì†í˜¸ë¯¼ ì†Œê°\nì§ì ‘ í•˜ê³  ì‹¶ì€ ê²ƒì„ ììœ ë¡­ê²Œ ë§Œë“¤ë©´ì„œ",
      " \nì•„ì´ë””ì–´ë¥¼ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê³¼ì •ì´ ì¦ê²¨ì› ìŠµë‹ˆë‹¤.",
      " \në§‰ë§‰í•œ ë¶€ë¶„ì„ íŒ€ì›ë¶„ë“¤ì´ë‘ í—¤ì³ë‚˜ê°ˆ ìˆ˜ ìˆì–´ ë§ì´ ë°°ì› ìŠµë‹ˆë‹¤.",
      "ìµœìœ¤í•˜ ì†Œê°\nì²˜ìŒ í•´ë³´ëŠ” íŒ€ í”„ë¡œì íŠ¸ë¼ ì–´ìƒ‰í–ˆì§€ë§Œ,",
      " \ní•¨ê»˜ í˜‘ë ¥í•˜ë©° í•˜ë‚˜ì˜ ê²°ê³¼ë¬¼ì„ ì™„ì„±í•´ê°€ëŠ” ê³¼ì •ì´",
      " \nì˜ë¯¸ ê¹Šì—ˆìŠµë‹ˆë‹¤. ì²« ì‘í’ˆì„ ì„±ê³µì ìœ¼ë¡œ",
      " \në§ˆë¬´ë¦¬í•˜ë©° ì„±ì·¨ê°ê³¼ ë³´ëŒì„ ëŠë‚„ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.",
      "ì¥ìœ¤ì•„ ì†Œê°\nì²˜ìŒì—ëŠ” ì˜ í•  ìˆ˜ ìˆì„ê¹Œ ê±±ì •ëëŠ”ë°",
      " \ní•˜ë‚˜ì”© êµ¬í˜„ë˜ë©´ì„œ ì¬ë¯¸ìˆëŠ” ê²½í—˜ì´ì—ˆìŠµë‹ˆë‹¤.",
      " \nAIë¥¼ í™œìš©í•˜ë©´ì„œ ì–´ë–»ê²Œ ì§ˆë¬¸ì„ íš¨ìœ¨ì ìœ¼ë¡œ í•´ì•¼ í• ê¹Œ?",
      " \në¼ëŠ” ê³ ë¯¼ì„ ë§ì´ í•´ë³´ê²Œ ëœ ê³„ê¸°ì˜€ìŠµë‹ˆë‹¤.",
      "AI percent\n85%",
      "AI content\nending, ëŒ“ê¸€ì°½, í˜ì´ì§€ ìŠ¤í¬ë¡¤, í”¼ë“œ ì´ë¯¸ì§€êµ¬ì„±, ",
      "AI content2\ní™”ë©´ì „í™˜, ë°°ê²½í™”ë©´ì½”ë“œ, ì¢‹ì•„ìš” ê¸°ëŠ¥, ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜ - ë°°ê²½",
      "Thank you for watching\nê°ì‚¬í•©ë‹ˆë‹¤",
      ""
];
let yPos = 700;
let baseSpacing = 100;
let speed = 2.0;
let minTextSize = 28;
let maxTextSize = 54;
let fadeZone = 100;
// --- drawEnding implementation ---
// helped by AI
// drawEnding(): í¬ë ˆë”§ ìŠ¤í¬ë¡¤ ì• ë‹ˆë©”ì´ì…˜ì„ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
function drawEnding() {
  // ê·¸ë¼ë°ì´ì…˜ ë°°ê²½: ìœ„ìª½ì€ ì§™ì€ íŒŒë€ìƒ‰, ì•„ë˜ìª½ì€ ê²€ì€ìƒ‰
  for (let i = 0; i < height; i++) {
    let inter = map(i, 0, height, 0, 1);
    let c = lerpColor(color(0, 0, 50), color(0, 0, 0), inter);
    stroke(c);
    line(0, i, width, i);
  }
  // í¬ë ˆë”§ í•­ëª©ì„ í•œ ì¤„ì”© ê·¸ë¦¼
  for (let i = 0; i < credits.length; i++) {
    const y = yPos + i * baseSpacing;
    if (y < -baseSpacing || y > height + baseSpacing) continue;
    let sizeFactor = map(y, 0, height, 0.8, 1.0);
    sizeFactor = constrain(sizeFactor, 0.8, 1.0);
    const textSizeNow = lerp(minTextSize, maxTextSize, (sizeFactor - 0.6) / (1.0 - 0.6));
    const x = width / 2;
    noStroke();
    fill(255);
    textAlign(CENTER, CENTER);
    const parts = credits[i].split("\n");
    if (parts.length === 2) {
      textSize(textSizeNow * 0.7);
      text(parts[0], x, y - textSizeNow * 0.5);
      textSize(textSizeNow * 0.4);
      text(parts[1], x, y + textSizeNow * 0.3);
    } else {
      textSize(textSizeNow);
      text(parts[0], x, y);
    }
  }
  yPos -= speed;
  const lastY = yPos + (credits.length - 1) * baseSpacing;
  if (lastY < -fadeZone) {
    yPos = height;
  }
}

const feedHeight = 600;
const feedCount = 6;
let transitionDuration = 300; // ms for slide animation

let idxs = Array(feedCount).fill(0);
let prevIdxs = Array(feedCount).fill(0);
let isTransitioningArr = Array(feedCount).fill(false);
let transitionStarts = Array(feedCount).fill(0);

let profileImgs = [], blueCheck;
let heartIcon, msgIcon, sentIcon, tagIcon, etcIcon;
let eraserIcon;

let likedArr = Array(feedCount).fill(false);
let likeStartCountArr = [10.3, 8.7, 12.5, 5.2, 9.1, 7.8];  // initial counts for each feed
let likeEndCountArr   = [164.6, 120.4, 200.1, 95.3, 110.2, 80.5];  // target counts for each feed
let likeAnimDuration = 2000; // animation duration in ms
let likeDisplayCountArr = likeStartCountArr.slice();
let likeAnimatingArr = Array(feedCount).fill(false);
let likeAnimStartTimeArr = Array(feedCount).fill(0);

let heartEmptyIcon;
let likeAvatar1;
let likeAvatar2;
const baseH = 550; // original layout height

// ëŒ“ê¸€ ì• ë‹ˆë©”ì´ì…˜ globals
let commentAnimStart = 0;
let commentAnimDelay = 750;       // ms between bubbles
let commentFadeDuration = 400;    // ms fade-in per bubble
let commentAnimActive = false;
let lastAnimIndex = -1;
let initialCommentLoad = false;

// Like animation globals
// let likeStartCount = 10.3;
// let likeEndCount = 164.6;
// let likeDisplayCount = likeStartCount;
// let likeAnimStartTime = 0;
// let likeAnimDuration = 1000; // animation duration in ms
// let likeAnimating = false;
let commentsVisibleArr = Array(feedCount).fill(false);

let commentAnimStartArr = Array(feedCount).fill(0);
let lastAnimIndexArr = Array(feedCount).fill(-1);
let commentAnimActiveArr = Array(feedCount).fill(false);
let initialCommentLoadArr = Array(feedCount).fill(false);
let commentInputs = [];
let submitButtons = [];
const initialCommentsArr = [
  ["ë©‹ì§„ ì‚¬ì§„ì´ë„¤ìš”!", "ì˜¤ ëŒ€ë°• ğŸ‘", "ìŠˆí¼ë…¸ë°”!!", "ì—ìŠ¤íŒŒ-!!"],               // feed 0
  ["ë‚ ì”¨ ì—„ì²­ ì¢‹ë‹¤", "ì†ì´ˆ?", "ì´ì—´", "ë‚˜ë„ ë°ë ¤ê°€"],         // feed 1
  ["ìì—°ì´ ì•„ë¦„ë‹µë„¤ìš”", "ì–´ë””ì¸ì§€ ì•Œë ¤ì£¼ì„¸ìš”"],   // feed 2
  ["ë©‹ì§„ ì‚¬ì§„!", "ì˜ ë§Œë“¤ì—ˆì–´ìš”", "ë¶„ìœ„ê¸° ì¡ë„¼", "í˜ë‚´"],         // feed 3
  ["ì–´ë””ê°€", "ì–´ë‘¡ë‹¤", "ë¬´ìŠ¨ ì˜ë¯¸?", "ë°¤ê¸¸ ì¡°ì‹¬í•´"],             // feed 4
  ["ë©‹ì§„ ì‘í’ˆ", "ëŒ€ë°•"],                       // feed 5
];
let commentsArr = [];
let storedCommentsArr = [];
for (let i = 0; i < feedCount; i++) {
  commentsArr[i] = initialCommentsArr[i].slice();
  storedCommentsArr[i] = [];
}

let currentCommentFeedIdx = 0;

// Transition globals
// let isTransitioning = false;
// let transitionStart = 0;
// let prevIdx = 0;
let transitionDir = 1; // 1 = next (slide left), -1 = previous (slide right)

const usernames = ["iamd", "character_a", "sone", "im_b", "namec", "flow"];

let isFeedScreen = true;
// Pull-to-refresh globals for Reels screen
let isPulling = false;
let pullStartY = 0;
let pullDistance = 0;
const pullThreshold = 50;
let isRefreshing = false;
let refreshStartTime = 0;
let refreshBgColor = null;

// Heart animation globals for pull-to-refresh
let hearts = [];
let startTime = 0;
const burstCount = 20;
const spawnRate = 5;

// Heart class (same as before, assumed to be above)
class Heart {
  constructor() {
    this.x = random(40, width - 40);
    this.y = height + random(20, 100);
    this.size = random(24, 40);
    this.speed = random(2, 4);
    this.color = color(random(200,255), random(80,180), random(120,255), 180);
    this.amp = random(10, 40);
    this.freq = random(0.015, 0.025);
    this.phase = random(TWO_PI);
  }
  update() {
    this.y -= this.speed;
    this.x += sin(this.y * this.freq + this.phase) * this.amp * 0.01;
  }
  draw() {
    push();
    translate(this.x, this.y);
    scale(this.size / 32);
    noStroke();
    fill(this.color);
    beginShape();
    vertex(0, -10);
    bezierVertex(15, -22, 36, -4, 0, 24);
    bezierVertex(-36, -4, -15, -22, 0, -10);
    endShape(CLOSE);
    pop();
  }
}

// Initialize a burst of hearts when refresh starts
function startHeartBurst() {
  bgmAudio.pause();
  bgmAudio.currentTime = 0;
  bgmHappyAudio.currentTime = 0;
  bgmHappyAudio.play();

  hearts = [];
  startTime = millis();
  for (let i = 0; i < burstCount; i++) {
    hearts.push(new Heart());
  }
}

// Update and draw hearts during refresh
function runHeartAnimation() {
  if (millis() - startTime < 2500 && frameCount % spawnRate === 0) {
    for (let i = 0; i < 5; i++) {
      hearts.push(new Heart());
    }
  }
  for (let i = hearts.length - 1; i >= 0; i--) {
    hearts[i].update();
    hearts[i].draw();
    if (hearts[i].y + hearts[i].size < 0) {
      hearts.splice(i, 1);
    }
  }
  if (millis() - startTime >= 2500 && hearts.length === 0) {
    // ready for next pull
    startTime = millis();
  }
}

// ì›í˜• í´ë¦¬í•‘ í›„ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
function drawCircularImage(img, cx, cy, r) {
  drawingContext.save();
  drawingContext.beginPath();
  drawingContext.arc(cx, cy, r, 0, TWO_PI);
  drawingContext.clip();
  // ì´ë¯¸ì§€ ì¤‘ì•™ ì •ì‚¬ê°í˜• ì˜ì—­ ê³„ì‚°
  let pw = img.width, ph = img.height;
  let pr = min(pw, ph);
  let sx = (pw - pr) / 2, sy = (ph - pr) / 2;
  image(img, cx, cy, r * 2, r * 2, sx, sy, pr, pr);
  drawingContext.restore();
}

// object-fit: cover ë°©ì‹ìœ¼ë¡œ ì •ì‚¬ê°í˜•ì— ì´ë¯¸ì§€ ì±„ìš°ê¸°
function drawCoverSquare(img, x, y, w, h) {
  let arCanvas = w / h;
  let arImg = img.width / img.height;
  let cropW, cropH;
  if (arImg > arCanvas) {
    cropH = img.height;
    cropW = cropH * arCanvas;
  } else {
    cropW = img.width;
    cropH = cropW / arCanvas;
  }
  let sx = (img.width - cropW) / 2;
  let sy = (img.height - cropH) / 2;
  image(img, x + w/2, y + h/2, w, h, sx, sy, cropW, cropH);
}

// Load all image assets
// helped by AI
// loadAssets(): ì´ë¯¸ì§€ ë° ì˜¤ë””ì˜¤ ìì‚°ì„ ë¯¸ë¦¬ ë¡œë“œí•©ë‹ˆë‹¤.
function loadAssets() {
  let urlHeader = "https://sonst07.github.io/p5js4/instagram";

  feedImgs = [];
  // Feed 0 images
  feedImgs[0] = [
    loadImage(urlHeader + "/img1.png"),
    loadImage(urlHeader + "/img2.png"),
    loadImage(urlHeader + "/img4.png")
  ];
  // Feed 1 images
  feedImgs[1] = [
    loadImage(urlHeader + "/aniA.png")
  ];
  // Feed 2 images (third feed)
  feedImgs[2] = [
    loadImage(urlHeader + "/nature1.png"),
    loadImage(urlHeader + "/nature2.png"),
    loadImage(urlHeader + "/nature3.png")
  ];
  // Feed 3 images
  feedImgs[3] = [
    loadImage(urlHeader + "/aniB.png")
  ];
  // Feed 4 images
  feedImgs[4] = [
    loadImage(urlHeader + "/aniC.png")
  ];
  // Feed 5 images
  feedImgs[5] = [
    // loadImage(urlHeader + "/imgD1.png"),
    // loadImage(urlHeader + "/imgD2.png"),
    // loadImage(urlHeader + "/imgD3.png")
    loadImage(urlHeader + "/flow1.jpg")
  ];
  // Profile images per feed
  profileImgs[0] = loadImage(urlHeader + "/profile0.png");
  profileImgs[1] = loadImage(urlHeader + "/profile1.png");
  profileImgs[2] = loadImage(urlHeader + "/profile2.png");
  profileImgs[3] = loadImage(urlHeader + "/profile3.png");
  profileImgs[4] = loadImage(urlHeader + "/profile4.png");
  profileImgs[5] = loadImage(urlHeader + "/profile5.png");
  blueCheck = loadImage(urlHeader + "/badge.png");
  heartIcon = loadImage(urlHeader + "/heart.png");
  msgIcon   = loadImage(urlHeader + "/msg.png");
  sentIcon  = loadImage(urlHeader + "/sent.png");
  tagIcon   = loadImage(urlHeader + "/tag.png");
  etcIcon   = loadImage(urlHeader + "/etc.png");
  heartEmptyIcon = loadImage(urlHeader + "/heart_empty.png");
  likeAvatar1 = loadImage(urlHeader + "/like3.png");
  likeAvatar2 = loadImage(urlHeader + "/like2.png");
  eraserIcon = loadImage(urlHeader + "/eraser.png");
  instaUpperImg = loadImage(urlHeader + "/insta_upper.jpeg");
  reelsImgs = [];
  reelsImgs.push(loadImage(urlHeader + "/reels_main0.jpeg"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main1.jpeg"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main2.jpeg"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main3.jpeg"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main4.jpeg"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main5.jpeg"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main6.png"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main7.png"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main7.png"));
  reelsImgs.push(loadImage(urlHeader + "/reels_main7.png"));
}

// helped by AI
// Create comment inputs and buttons
function setupComments() {
  for (let i = 0; i < feedCount; i++) {
    let inp = createInput();
    inp.parent('feed-container');
    inp.size(width - 180);
    inp.style('background-color', 'rgba(255, 255, 255, 0.6)');
    inp.style('border-radius', '12px');
    inp.style('border', 'none');
    inp.style('padding', '8px');
    inp.style('font-size', '14px');
    inp.hide();
    commentInputs.push(inp);

    let btn = createButton('ë³´ë‚´ê¸°');
    btn.parent('feed-container');
    btn.style('background-color', 'rgba(55, 115, 219, 0.6)');
    btn.style('color', '#ffffff');
    btn.style('border-radius', '12px');
    btn.style('border', 'none');
    btn.style('padding', '8px 12px');
    btn.style('font-size', '14px');
    btn.style('cursor', 'pointer');
    btn.hide();
    btn.mousePressed(submitComment);
    submitButtons.push(btn);

    let y = i * feedHeight + feedHeight - 65;
    inp.position(51, y + 250);
    btn.position(59 + inp.width + 10, y + 250);
  }
}

// Draw bottom icons, like info, and comments
// helped by AI
function drawBottomSection(feedIdx) {
  drawBottomIcons(feedIdx);
  drawLikesInfo();
  drawCommentBubbles(feedIdx);
}

// helped by AI
// í˜ì´ì§€ ì¸ë””ì¼€ì´í„° ê·¸ë¦¬ê¸°
function drawPageIndicator(count, idx) {
  let py = (feedHeight + width) / 2 - 28;
  let spacing = 13;
  let size = 7;
  for (let i = 0; i < count; i++) {
    fill(i === idx ? "#1DA1F2" : "#555");
    noStroke();
    ellipse(width/2 + (i - (count-1)/2) * spacing, py, size);
  }
}

// helped by AI
// í•˜ë‹¨ ì•„ì´ì½˜ê³¼ ìˆ«ì í‘œì‹œ
function drawBottomIcons(feedIdx) {
    fill("#FFF");
    let num = -58;
    let num2 = 2;

    // update like display count if animating
    if (likeAnimatingArr[feedIdx]) {
      let t = (millis() - likeAnimStartTimeArr[feedIdx]) / likeAnimDuration;
      if (t >= 1) {
        likeDisplayCountArr[feedIdx] = likeEndCountArr[feedIdx];
        likeAnimatingArr[feedIdx] = false;
      } else {
        likeDisplayCountArr[feedIdx] = lerp(likeStartCountArr[feedIdx], likeEndCountArr[feedIdx], t);
      }
    }

    // image(heartIcon, 32, feedHeight - 40 + num, 30, 30);
    image(likedArr[feedIdx] ? heartIcon : heartEmptyIcon, 32, feedHeight - 40 + num, 30, 30);
    text(`${likeDisplayCountArr[feedIdx].toFixed(1)}ë§Œ`, 52, feedHeight - 40 + num + num2);
    image(msgIcon, 136, feedHeight - 40 + num, 30, 30);
    text("8,507", 154, feedHeight - 40 + num + num2);
    image(sentIcon, 224, feedHeight - 40 + num, 30, 30);
    text("3.8ë§Œ", 241, feedHeight - 40 + num + num2);
    image(tagIcon, width - 38, feedHeight - 40 + num, 27, 30);
    // eraser icon
    image(eraserIcon, width - 68, feedHeight - 40 + num, 30, 30);
}

// helped by AI
// ì¢‹ì•„ìš” ë° ë‚ ì§œ ì •ë³´ ê·¸ë¦¬ê¸° (ì„¸ ë²ˆì§¸ ì˜ì—­)
function drawLikesInfo() {
  let ay = baseH - 10; // position 20px below original layout
  let size = 24;
  // ì²« ë²ˆì§¸ ì•„ë°”íƒ€ ì´ë¯¸ì§€
  drawCircularImage(likeAvatar1, 16 + size/2, ay, size/2);
  // ë‘ë²ˆì§¸ ì•„ë°”íƒ€: í° ì› + ì´ë¯¸ì§€
  fill(255);
  drawCircularImage(likeAvatar2, 16 + size + 10, ay, size/2);
  // í…ìŠ¤íŠ¸
  fill(255);
  textSize(14);
  textAlign(LEFT, CENTER);
  text("karina_asp ë‹˜ ì™¸ ì—¬ëŸ¬ ëª…ì´ ì¢‹ì•„í•©ë‹ˆë‹¤", 16 + size*2 + 8, ay);
  // ë‚ ì§œ
  fill(150);
  text("4ì›” 29ì¼", 16, baseH + 22); // position 45px below original layout
}

// helped by AI
// ëŒ“ê¸€ ë§í’ì„  ì• ë‹ˆë©”ì´ì…˜ (ëŒ€í™” ìŠ¤íƒ€ì¼)
function drawCommentBubbles(feedIdx) {
  if (!commentsVisibleArr[feedIdx]) return;
  let elapsed = millis() - commentAnimStartArr[feedIdx];
  push();
  // ë°˜íˆ¬ëª… ë°°ê²½
  fill(0, 180);
  rect(0, 0, width, feedHeight);
  textSize(14);
  textAlign(LEFT, TOP);

  let startY = 60;
  let lineH = 48;

  const feedComments = commentsArr[feedIdx];
  for (let i = 0; i < feedComments.length; i++) {
    let alpha;
    if (initialCommentLoadArr[feedIdx] && commentAnimActiveArr[feedIdx]) {
      let appearTime = i * commentAnimDelay;
      let t = constrain((elapsed - appearTime) / commentFadeDuration, 0, 1);
      alpha = t * 255;
      if (i === feedComments.length - 1 && t === 1) {
        commentAnimActiveArr[feedIdx] = false;
        initialCommentLoadArr[feedIdx] = false;
      }
    } else if (!initialCommentLoadArr[feedIdx] && i === lastAnimIndexArr[feedIdx] && commentAnimActiveArr[feedIdx]) {
      let t = constrain(elapsed / commentFadeDuration, 0, 1);
      alpha = t * 255;
      if (t >= 1) {
        commentAnimActiveArr[feedIdx] = false;
      }
    } else {
      alpha = 255;
    }
    let bubbleAlpha = alpha * 0.5;
    let msg = feedComments[i];

    // Bubble dimensions
    let padding = 12;
    let tw = textWidth(msg);
    let bw = tw + padding * 2;
    let bh = textAscent() + textDescent() + padding;
    let by = startY + i * lineH;
    let bx, bubbleColor, textColor;

    if (i % 2 === 0) {
      bubbleColor = [55, 115, 219, bubbleAlpha];
      textColor = [255, 255, 255, alpha];
      bx = width - bw - 20;
    } else {
      bubbleColor = [255, 255, 255, bubbleAlpha];
      textColor = [0, 0, 0, alpha];
      bx = 20;
    }

    fill(...bubbleColor);
    noStroke();
    rect(bx, by, bw, bh, 12);
    fill(...bubbleColor);
    triangle(
      i % 2 === 0 ? bx + bw - 16 : bx + 16, by + bh,
      i % 2 === 0 ? bx + bw - 24 : bx + 24, by + bh,
      i % 2 === 0 ? bx + bw - 20 : bx + 20, by + bh + 8
    );
    fill(...textColor);
    text(msg, bx + padding, by + (padding / 2) + 3);
  }

  pop();
}

// helped by AI
function preload() {
  loadAssets();
  bgmAudio = new Audio('BGMtotal.mp3');
  bgmAudio.loop = true;
  bgmSuperAudio = new Audio('BGMsuper.mp3');
  bgmSuperAudio.loop = true;
  bgmKeyboardAudio = new Audio('BGMkeyboard.mp3');  // ì—¬ê¸° ì¶”ê°€
  bgmKeyboardAudio.loop = true;
  bgmHappyAudio = new Audio('BGMhappy.mp3');
  bgmHappyAudio.loop = true;
}

// helped by AI
function drawUpperLine(feedIdx) {
  // Profile circle
  drawCircularImage(profileImgs[feedIdx], 37, 30, 18);

  // Username text
  fill(255);
  textSize(18);
  const textX = 68;
  const textY = 32;
  const name = usernames[feedIdx];
  text(name, textX, textY);

  // Badge positioned after text with consistent gap
  const badgePadding = 17; // gap between text and badge
  const badgeSize = 26;
  const badgeX = textX + textWidth(name) + badgePadding;
  const badgeY = textY - badgeSize / 2 + 14; // vertically center badge to text baseline
  image(blueCheck, badgeX, badgeY, badgeSize, badgeSize);

  // "etc" icon at right
  image(etcIcon, width - 28, 30, 23, 32);
}

// helped by AI
// ëŒ“ê¸€ ì „ì†¡ í•¸ë“¤ëŸ¬
// submitComment(): ì‚¬ìš©ìê°€ ì…ë ¥í•œ ëŒ“ê¸€ì„ ì²˜ë¦¬í•˜ê³  í‘œì‹œí•©ë‹ˆë‹¤.
function submitComment() {
  let inp = commentInputs[currentCommentFeedIdx];
  let newComment = inp.value().trim();
  if (newComment) {
    const idx = currentCommentFeedIdx;
    commentsArr[idx].push(newComment);
    storedCommentsArr[idx].push(newComment);
    lastAnimIndexArr[idx] = commentsArr[idx].length - 1;
    commentAnimStartArr[idx] = millis();
    commentAnimActiveArr[idx] = true;
    initialCommentLoadArr[idx] = false;
    commentsVisibleArr[idx] = true;
    inp.value('');
  }
}

// helped by AI
// Close comment input if click is outside comment area
function closeCommentInput(feedIdx, localY) {
  const ix = commentInputs[feedIdx].x;
  const iy = commentInputs[feedIdx].y;
  const iw = commentInputs[feedIdx].width;
  const ih = 24;
  const bx0 = submitButtons[feedIdx].x;
  const by0 = submitButtons[feedIdx].y;
  const bw0 = 50;
  const bh0 = 24;
  const mx0 = 136, my0 = feedHeight - 40 - 58, mw0 = 30, mh0 = 30;
  if (commentsVisibleArr[feedIdx]) {
    const overMsg = mouseX > mx0 - mw0/2 && mouseX < mx0 + mw0/2
                 && localY > my0 - mh0/2 && localY < my0 + mh0/2;
    const overInput = mouseX > ix && mouseX < ix + iw
                    && mouseY > iy && mouseY < iy + ih;
    const overBtn = mouseX > bx0 && mouseX < bx0 + bw0
                  && mouseY > by0 && mouseY < by0 + bh0;
    if (!overMsg && !overInput && !overBtn) {
      commentsVisibleArr[feedIdx] = false;
      commentAnimActiveArr[feedIdx] = false;
      commentInputs[feedIdx].hide();
      submitButtons[feedIdx].hide();
      bgmKeyboardAudio.pause(); 
      bgmKeyboardAudio.currentTime = 0;
      return true;
    }
  }
  return false;
}

// helped by AI
// Toggle like state when heart icon clicked
function toggleLike(feedIdx, localY) {
  const hx = 32, hy = feedHeight - 40 - 58, hw = 30, hh = 30;
  if (mouseX > hx - hw/2 && mouseX < hx + hw/2
   && localY > hy - hh/2 && localY < hy + hh/2) {
    likedArr[feedIdx] = !likedArr[feedIdx];
    if (likedArr[feedIdx]) {
      likeDisplayCountArr[feedIdx] = likeStartCountArr[feedIdx];
      likeAnimStartTimeArr[feedIdx] = millis();
      likeAnimatingArr[feedIdx] = true;
    } else {
      likeDisplayCountArr[feedIdx] = likeStartCountArr[feedIdx];
    }
    return true;
  }
  return false;
}

// helped by AI
// Show comment input when comment icon clicked
function openCommentInput(feedIdx, localY) {
  const mx = 136, my = feedHeight - 40 - 58, mw = 30, mh = 30;
  if (mouseX > mx - mw/2 && mouseX < mx + mw/2
   && localY > my - mh/2 && localY < my + mh/2) {
    currentCommentFeedIdx = feedIdx;
    commentsVisibleArr[feedIdx] = true;
    commentAnimStartArr[feedIdx] = millis();
    commentAnimActiveArr[feedIdx] = true;
    initialCommentLoadArr[feedIdx] = true;
    lastAnimIndexArr[feedIdx] = -1;
    commentInputs[feedIdx].show();
    submitButtons[feedIdx].show();
    bgmKeyboardAudio.currentTime = 0;
    bgmKeyboardAudio.play();  
    return true;
  }
  return false;
}

// helped by AI
// Change feed image if click in image region
function changeFeedImage(feedIdx, localY) {
  const yStart = (feedHeight - width) / 2 - 15;
  const yEnd = yStart + width;
  if (localY > yStart && localY < yEnd) {
    if (feedIdx === 0 && bgmSuperAudio.currentTime == 0) {
      bgmSuperAudio.currentTime = 0;
      bgmSuperAudio.play();
    }
    if (feedIdx === 1) {
      bgmSuperAudio.pause();
      bgmSuperAudio.currentTime = 0;
      bgmAudio.currentTime = 0;
      bgmAudio.play();
    }
    prevIdxs[feedIdx] = idxs[feedIdx];
    let imgCount = feedImgs[feedIdx].length;
    if (mouseX < width / 2) {
      idxs[feedIdx] = (idxs[feedIdx] + imgCount - 1) % imgCount;
      transitionDir = -1;
    } else {
      idxs[feedIdx] = (idxs[feedIdx] + 1) % imgCount;
      transitionDir = 1;
    }
    isTransitioningArr[feedIdx] = true;
    transitionStarts[feedIdx] = millis();
    return true;
  }
  return false;
}

// helped by AI
function setup() {
  // ìº”ë²„ìŠ¤ ìƒì„±
  let c = createCanvas(390, feedHeight * feedCount);
  c.parent('feed-container');
  imageMode(CENTER);
  textFont("Arial");
  textAlign(LEFT, CENTER);

  setupComments();
  // No heart initialization here (moved to startHeartBurst)
}

// setup(): ìº”ë²„ìŠ¤ ë° ëŒ“ê¸€ ì…ë ¥ í•„ë“œë¥¼ ì´ˆê¸° ì„¤ì •í•©ë‹ˆë‹¤.
// helped by AI
// Draws the feed image with sliding transition
function drawFeedImage(feedIdx) {
  let images = feedImgs[feedIdx];
  if (isTransitioningArr[feedIdx]) {
    let t = (millis() - transitionStarts[feedIdx]) / transitionDuration;
    if (t >= 1) {
      t = 1;
      isTransitioningArr[feedIdx] = false;
    }
    let prevOffset = transitionDir * (-t) * width;
    drawCoverSquare(images[prevIdxs[feedIdx]], prevOffset, (feedHeight - width) / 2 - 46, width, width);
    let currOffset = transitionDir * (1 - t) * width;
    drawCoverSquare(images[idxs[feedIdx]], currOffset, (feedHeight - width) / 2 - 46, width, width);
  } else {
    drawCoverSquare(images[idxs[feedIdx]], 0, (feedHeight - width) / 2 - 46, width, width);
  }
}

// helped by AI
function drawFeed(feedIdx) {
  // draw feed background
  noStroke();
  fill(0);
  rect(0, 0, width, feedHeight);
  // ìœ— ë¼ì¸
  drawUpperLine(feedIdx);
  // ì´ë¯¸ì§€ ë³¸ë¬¸ ë° ìŠ¬ë¼ì´ë“œ ì• ë‹ˆë©”ì´ì…˜
  drawFeedImage(feedIdx);
  // í˜ì´ì§€ ì¸ë””ì¼€ì´í„°
  drawPageIndicator(feedImgs[feedIdx].length, idxs[feedIdx]);
  // í•˜ë‹¨ ì•„ì´ì½˜, ì¢‹ì•„ìš” ì •ë³´, ëŒ“ê¸€
  drawBottomSection(feedIdx);
}

// helped by AI
// Handle pull start on Reels screen
function handleReelsMousePressed() {
  if (!isFeedScreen && mouseY < 50) {
    isPulling = true;
    pullStartY = mouseY;
    pullDistance = 0;
    return true;
  }
  return false;
}
// helped by AI
// Handle pull move
function handleReelsMouseDragged() {
  if (isPulling) {
    pullDistance = constrain(mouseY - pullStartY, 0, 200);
    return true;
  }
  return false;
}
// helped by AI
// Handle pull release
function handleReelsMouseReleased() {
  if (isPulling) {
    if (pullDistance > pullThreshold) {
      refreshBgColor = color(random(255), random(255), random(255));
      isRefreshing = true;
      refreshStartTime = millis();
      // perform refresh logic
      loadAssets();
    }
    isPulling = false;
    return true;
  }
  return false;
}
// helped by AI
// Draw pull-to-refresh spinner
function drawPullToRefresh() {
  let y = pullDistance / 2 + 50;
  let angle = isRefreshing
    ? ((millis() - refreshStartTime) / 400) * TWO_PI
    : map(pullDistance, 0, pullThreshold, 0, PI);
  push();
  translate(width/2, y);
  noFill();
  stroke(255); // Spinner is now white
  strokeWeight(4);
  arc(0, 0, 30, 30, 0, angle);
  pop();
  if (isRefreshing && millis() - refreshStartTime > 400) {
    isRefreshing = false;
    startHeartBurst();
    pullDistance = 0;
    refreshBgColor = null;
  }
}

// helped by AI
function drawReelsScreen() {
  // Show ending credits if at reelIdx 9
  if (reelIdx === 9) {
    drawEnding();
    return;
  }
  // Determine dimensions based on current reel image
  const currentImg = reelsImgs[isReelTransitioning ? reelIdx : reelIdx];
  const iw = width;
  const ih = currentImg.height * (width / currentImg.width);
  resizeCanvas(width, ih);
  select('#feed-container').style('overflow-y', 'hidden');
  
  // Background during pull-to-refresh
  if (isPulling || isRefreshing) {
    background(0);
  } else if (refreshBgColor !== null) {
    background(refreshBgColor);
  } else {
    background(0);
  }

  if (isReelTransitioning) {
    // Calculate transition progress
    let t = (millis() - reelTransitionStart) / reelTransitionDuration;
    if (t >= 1) {
      t = 1;
      isReelTransitioning = false;
    }
    // Previous and next images
    const prevImg = reelsImgs[prevReelIdx];
    const nextImg = reelsImgs[reelIdx];
    // Heights for each image (maintain aspect ratio)
    const prevH = prevImg.height * (width / prevImg.width);
    const nextH = nextImg.height * (width / nextImg.width);

    // Compute Y positions depending on scroll direction
    let prevY, nextY;
    if (reelTransitionDir === 1) {
      // scrolling down: previous moves up, next comes from below
      prevY = ih / 2 - t * ih;
      nextY = ih / 2 + (ih - t * ih);
    } else {
      // scrolling up: previous moves down, next comes from above
      prevY = ih / 2 + t * ih;
      nextY = ih / 2 - (ih - t * ih);
    }
    // Draw both images with pull-distance offset
    push();
    translate(0, pullDistance);
    imageMode(CENTER);
    image(prevImg, width / 2, prevY, iw, prevH);
    image(nextImg, width / 2, nextY, iw, nextH);
    pop();
  } else {
    // No transition: draw single current image
    push();
    translate(0, pullDistance);
    imageMode(CENTER);
    image(currentImg, width / 2, ih / 2, iw, ih);
    pop();
  }
  if (reelIdx === 4 && !isReelTransitioning) {
    // Embed aniA/index.html as part of the reel inside the feed-container
    const container = document.getElementById('feed-container');
    // Ensure container clips the iframe and is positioned relative
    container.style.position = 'relative';
    container.style.overflow = 'hidden';
    if (!document.getElementById('aniA-frame')) {
      const iframe = document.createElement('iframe');
      iframe.id = 'aniA-frame';
      iframe.src = 'aniA/index.html';
      iframe.style.position = 'absolute';
      iframe.style.top = '0';
      iframe.style.left = '0';
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.style.border = 'none';
      iframe.style.zIndex = '998'; // below bottom overlay and phone frame
      iframe.style.pointerEvents = 'auto';
      iframe.style.opacity = '0';
      iframe.style.transition = 'opacity 1.5s ease';
      container.appendChild(iframe);
      // Fade in iframe smoothly after it is in the DOM
      requestAnimationFrame(() => {
        iframe.style.opacity = '1';
      });
      // Ensure wheel events inside the iframe propagate to the parent so Reels can detect scroll
      iframe.onload = function () {
        iframe.contentWindow.addEventListener(
          'wheel',
          function (e) {
            // Relay the wheel delta to the parent window
            window.dispatchEvent(
              new WheelEvent('wheel', {
                deltaY: e.deltaY,
                deltaX: e.deltaX,
                deltaMode: e.deltaMode,
              })
            );
            // Prevent the iframe from scrolling internally
            e.preventDefault();
          },
          { passive: false }
        );
      };
    }
    if (reel4StartTime === null) {
      reel4StartTime = millis();
    }
  } else {
    reel4StartTime = null;
    const existing = document.getElementById('aniA-frame');
    if (existing) existing.remove();
  }
  // Embed aniB/index.html when on reel 5
  if (reelIdx === 5 && !isReelTransitioning) {
    const containerB = document.getElementById('feed-container');
    containerB.style.position = 'relative';
    containerB.style.overflow = 'hidden';
    if (!document.getElementById('aniB-frame')) {
      const iframeB = document.createElement('iframe');
      iframeB.id = 'aniB-frame';
      iframeB.src = 'aniB/index.html';
      iframeB.style.position = 'absolute';
      iframeB.style.top = '0';
      iframeB.style.left = '0';
      iframeB.style.width = '100%';
      iframeB.style.height = '100%';
      iframeB.style.border = 'none';
      iframeB.style.zIndex = '998';
      iframeB.style.pointerEvents = 'auto';
      iframeB.style.opacity = '0';
      iframeB.style.transition = 'opacity 1.4s ease';
      containerB.appendChild(iframeB);
      requestAnimationFrame(() => {
        iframeB.style.opacity = '1';
      });
      iframeB.onload = function () {
        iframeB.contentWindow.addEventListener(
          'wheel',
          function (e) {
            window.dispatchEvent(
              new WheelEvent('wheel', {
                deltaY: e.deltaY,
                deltaX: e.deltaX,
                deltaMode: e.deltaMode,
              })
            );
            e.preventDefault();
          },
          { passive: false }
        );
      };
    }
  } else {
    const existingB = document.getElementById('aniB-frame');
    if (existingB) existingB.remove();
  }
  // Embed aniC/index.html when on reel 6
  if (reelIdx === 6 && !isReelTransitioning) {
    const containerC = document.getElementById('feed-container');
    containerC.style.position = 'relative';
    containerC.style.overflow = 'hidden';
    if (!document.getElementById('aniC-frame')) {
      const iframeC = document.createElement('iframe');
      iframeC.id = 'aniC-frame';
      iframeC.src = 'aniC/index.html';
      iframeC.style.position = 'absolute';
      iframeC.style.top = '0';
      iframeC.style.left = '0';
      iframeC.style.width = '100%';
      iframeC.style.height = '100%';
      iframeC.style.border = 'none';
      iframeC.style.zIndex = '998';
      iframeC.style.pointerEvents = 'auto';
      iframeC.style.opacity = '0';
      iframeC.style.transition = 'opacity 1.4s ease';
      containerC.appendChild(iframeC);
      requestAnimationFrame(() => {
        iframeC.style.opacity = '1';
      });
      iframeC.onload = function () {
        iframeC.contentWindow.addEventListener(
          'wheel',
          function (e) {
            window.dispatchEvent(
              new WheelEvent('wheel', {
                deltaY: e.deltaY,
                deltaX: e.deltaX,
                deltaMode: e.deltaMode,
              })
            );
            e.preventDefault();
          },
          { passive: false }
        );
      };
    }
  } else {
    const existingC = document.getElementById('aniC-frame');
    if (existingC) existingC.remove();
  }
  if (reelIdx === 8) {
    if (reel5StartTime === null) {
      reel5StartTime = millis();
    }
  } else {
    reel5StartTime = null;
  }
  // Combine all comments from all feeds
  const allComments = storedCommentsArr.flat();
  if (reelIdx === 7 && allComments.length > 0) {
    if (reel8StartTime === null) {
      reel8StartTime = millis();
    }
    // Sequential fade-in/fade-out for each bubble, all in one frame.
    const commentStartDelay = 1; // seconds before comments start
    let elapsed = max(0, (millis() - reel8StartTime) / 1000 - commentStartDelay);
    let cycle = 2;      // seconds between each bubble's start
    let fadeDur = 1;    // seconds for fade-in and fade-out
    let commentsToShow = allComments;
    let count = commentsToShow.length;
    textSize(14);
    textAlign(LEFT, TOP);
    let padding = 12, spacing = 18;
    let centerY = ih * 9 / 16;
    // Precompute bubble sizes for all comments
    let bubbleWidths = [], bubbleHeights = [];
    for (let i = 0; i < count; i++) {
      let tw = textWidth(commentsToShow[i]);
      bubbleWidths.push(tw + padding*2);
      bubbleHeights.push(textAscent() + textDescent() + padding);
    }
    for (let i = 0; i < count; i++) {
      let startTime = i * cycle;
      let t = elapsed - startTime;
      if (t < 0) continue;                    // not yet appeared
      let alpha;
      if (t < fadeDur) {                      // fade-in
        alpha = t / fadeDur * 255;
      } else if (t < cycle) {                 // fully visible
        alpha = 255;
      } else if (t < cycle + fadeDur) {       // fade-out
        alpha = (1 - (t - cycle) / fadeDur) * 255;
      } else {
        continue;                             // done fading
      }
      let bw = bubbleWidths[i], bh = bubbleHeights[i];
      let bx = (width - bw) / 2;
      let y = centerY - i * (bh + spacing);
      let bubbleAlpha = alpha * 0.6;
      fill(60,60,60,bubbleAlpha); noStroke();
      rect(bx, y, bw, bh, 12);
      fill(30,30,30,bubbleAlpha);
      let tx = bx + bw/2 - 10;
      triangle(tx, y+bh, tx+6, y+bh, tx, y+bh+8);
      fill(255,255,255,alpha);
      text(commentsToShow[i], bx+padding, y+(padding/2)+3);
    }
  } else if (reelIdx === 7) {
    reel8StartTime = null;
  }

  if (reelIdx === 8) {
    let fullText = "ì§€ë‚˜ê°€ëŠ” ë§ì´, ê¹Šê²Œ ìŠ¤ë©°ë“¤ì—ˆë‹¤.";
    let elapsed = millis() - reel5StartTime;
    textSize(20);
    textAlign(CENTER, CENTER);
    fill(255);
    let displayText = "";
    // After 3s of cursor blinking, start typing
    let typingDelay = 3000; // ms
    let typingElapsed = max(0, elapsed - typingDelay);
    if (typingElapsed > 0) {
      let charInterval = 180; // ms per char
      // base chars without pauses
      let rawChars = floor(typingElapsed / charInterval);
      // positions to pause at
      let commaPos = fullText.indexOf(',') + 1;
      let depthPos = fullText.indexOf('ê¹Šê²Œ') + 'ê¹Šê²Œ'.length;
      let pauseDur = 2000; // 2s pause

      let charsToShow;
      if (rawChars < commaPos) {
        charsToShow = rawChars;
      } else if (typingElapsed < commaPos * charInterval + pauseDur) {
        // during first pause after comma
        charsToShow = commaPos;
      } else if (rawChars < depthPos + pauseDur / charInterval) {
        // resume until depth position reached
        charsToShow = rawChars - pauseDur / charInterval;
      } else if (typingElapsed < depthPos * charInterval + pauseDur + pauseDur) {
        // second pause after ê¹Šê²Œ
        charsToShow = depthPos;
      } else {
        // after second pause
        charsToShow = rawChars - 2 * (pauseDur / charInterval);
      }
      charsToShow = constrain(charsToShow, 0, fullText.length);
      displayText = fullText.substring(0, charsToShow);
    }
    // Draw the text (may be empty during initial blink)
    text(displayText, width / 2, ih / 2);
    // Blinking cursor with 300ms initial delay
    let cursorDelay = 300;         // ms before cursor starts
    let cursorBlinkInterval = 500; // ms per blink
    let blinkOn = false;
    if (elapsed > cursorDelay) {
      blinkOn = floor((elapsed - cursorDelay) / cursorBlinkInterval) % 2 === 0;
    }
    if (blinkOn) {
      // Determine text width for cursor position
      let tw = textWidth(displayText);
      // If no text yet, center cursor
      let startX = width / 2 - tw / 2;
      let cursorX = startX + tw + 2;
      let textAscentVal = textAscent();
      let textDescentVal = textDescent();
      let cursorY1 = ih / 2 - textAscentVal / 2;
      let cursorY2 = ih / 2 + textDescentVal / 2;
      stroke(255);
      strokeWeight(2);
      line(cursorX, cursorY1, cursorX, cursorY2);
      noStroke();
    }
  }

  // Pull-to-refresh spinner if needed
  if (isPulling || isRefreshing) {
    drawPullToRefresh();
    return;
  }
  if (hearts.length > 0) {
    runHeartAnimation();
    return;
  }
}

function drawInstagramUpper() {
  imageMode(CORNER);
  image(instaUpperImg, 3, 7, width - 10, instaUpperImg.height * (width / instaUpperImg.width));
}

// helped by AI
function drawAllFeeds() {
  let instaUpperOffset = 6;
  translate(0, instaUpperImg.height * (width / instaUpperImg.width) + instaUpperOffset);
  imageMode(CENTER);
  for (let i = 0; i < feedCount; i++) {
    push();
    translate(0, i * feedHeight);
    drawFeed(i);
    pop();
  }
}

function drawFeedScreen() {
  // Restore canvas size and enable container scrolling for feed screen
  resizeCanvas(width, feedHeight * feedCount);
  select('#feed-container').style('overflow-y', 'auto');
  drawInstagramUpper();
  drawAllFeeds();
}

// helped by AI
function draw() {
// draw(): ë©”ì¸ ë£¨í”„ í•¨ìˆ˜, ì¸íŠ¸ë¡œ ë° í™”ë©´ ì „í™˜ ë¡œì§ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
  // Show intro page for first 5 seconds
  if (millis() < 4000) {
    // Ensure intro iframe exists
    if (!document.getElementById('intro-frame')) {
      const intro = document.createElement('iframe');
      intro.id = 'intro-frame';
      intro.src = 'intro/index.html';
      intro.style.position = 'fixed';
      intro.style.top = '0';
      intro.style.left = '0';
      intro.style.width = '100%';
      intro.style.height = '100%';
      intro.style.border = 'none';
      intro.style.zIndex = '1000';
      document.body.appendChild(intro);
    }
    return;
  } else {
    // Remove intro iframe once time has passed
    const intro = document.getElementById('intro-frame');
    if (intro) intro.remove();
  }

  clear();

  if (!isFeedScreen) {
    drawReelsScreen();
    return;
  }
  
  drawFeedScreen();
}

function handleBottomOverlayClick() {
  const overlayHeight = 60;
  const overlayY = height - overlayHeight;
  if (
    mouseY >= overlayY &&
    mouseY <= height &&
    mouseX >= 0 &&
    mouseX <= width
  ) {
    isFeedScreen = mouseX < width / 2;
    return true;
  }
  return false;
}

function handleFeedInteraction(event) {
  const overlayH = instaUpperImg.height * (width / instaUpperImg.width);
  const adjustedY = mouseY - overlayH;

  let feedIdx = Math.floor(adjustedY / feedHeight);
  let localY = adjustedY - feedIdx * feedHeight;

  if (event.target.id !== 'defaultCanvas0') return;
  if (feedIdx < 0 || feedIdx >= feedCount) return;

  if (closeCommentInput(feedIdx, localY)) return;
  if (toggleLike(feedIdx, localY)) return;
  if (openCommentInput(feedIdx, localY)) return;
  if (changeFeedImage(feedIdx, localY)) return;
}

function mousePressed(event) {
  if (handleReelsMousePressed()) return;
  if (handleBottomOverlayClick()) return;
  handleFeedInteraction(event);
}

function mouseDragged(event) {
  if (handleReelsMouseDragged()) return;
}
function mouseReleased(event) {
  if (handleReelsMouseReleased()) return;
}

function mouseWheel(event) {
  // ë¦´ìŠ¤ í™”ë©´ ì¤‘ì´ë©° ì• ë‹ˆë©”ì´ì…˜ì´ ì§„í–‰ ì¤‘ì´ì§€ ì•Šì„ ë•Œë§Œ ì²˜ë¦¬
  if (!isFeedScreen && !isReelTransitioning) {
    // ìŠ¤í¬ë¡¤ ë¸íƒ€ë¥¼ ëˆ„ì 
    reelScrollAccum += event.deltaY;
    // ëˆ„ì ê°’ì´ ì„ê³„ì¹˜ ì´ìƒì¼ ë•Œë§Œ í•œë²ˆ ì „í™˜ íŠ¸ë¦¬ê±°
    if (abs(reelScrollAccum) >= reelScrollThreshold) {
      prevReelIdx = reelIdx;
      if (reelScrollAccum > 0) {
        reelIdx = (reelIdx + 1) % reelsImgs.length;
        reelTransitionDir = 1;
      } else {
        reelIdx = (reelIdx - 1 + reelsImgs.length) % reelsImgs.length;
        reelTransitionDir = -1;
      }
      isReelTransitioning = true;
      reelTransitionStart = millis();
      reelScrollAccum = 0; // ëˆ„ì ê°’ ì´ˆê¸°í™”
    }
    return false; // ê¸°ë³¸ ìŠ¤í¬ë¡¤ ë°©ì§€
  }
}
// Preload alternate bottom image for smooth switching
const bottomAltImg = new Image();
bottomAltImg.src = 'insta_bottom2.jpeg';

// Add fade transition via CSS
const instaBottom = document.getElementById('insta-bottom');
instaBottom.style.transition = 'opacity 0.3s';
instaBottom.style.cursor = 'pointer'; // indicate clickable

instaBottom.addEventListener('click', function(event) {
  instaBottom.style.opacity = '0';
  const rect = instaBottom.getBoundingClientRect();
  const clickX = event.clientX - rect.left;
  if (clickX < rect.width / 2) {
    // left half clicked: show original insta_bottom.png
    instaBottom.src = 'insta_bottom3.png';
    isFeedScreen = true;
    document.getElementById('feed-container').scrollTop = 0;
    instaBottom.onload = () => {
      instaBottom.style.opacity = '1';
    };
    instaBottom.style.top = 'calc(38% + 394px)';
  } else {
    // right half clicked: show alternate insta_bottom2.jpeg
    instaBottom.src = 'insta_bottom2.jpeg';
    isFeedScreen = false;
    document.getElementById('feed-container').scrollTop = 0;
    instaBottom.onload = () => {
      instaBottom.style.opacity = '1';
    };
    instaBottom.style.top = 'calc(38% + 394px)';
  }
});
</script>
<img id="phone-frame" src="phone_layout.png" alt="Phone frame overlay">
</body>
</html>
